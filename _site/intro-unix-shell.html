<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Introduction to the UNIX Shell (Bash)</title>

  <link rel="stylesheet" href="/css/main.css">
  
</head>


<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>mozillo@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        
<!-- https://docs.mathjax.org/en/latest/configuration.html#local-config-files -->
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-AMS-MML_HTMLorMML,https://idcrook.github.io/assets/js/MathJaxLocal.js">
</script>



<article>
	<h2>Introduction to the UNIX Shell (Bash)</h2>
	<time datetime="2020-06-18T00:00:00+08:00" class="by-line"
		>18 Jun 2020</time
	>
	<iframe src="https://github.com/sponsors/pabloinsente/card" title="Sponsor pabloinsente" height="225" width="600" style="border: 0;"></iframe>

<p><strong>TL;DR</strong> sections:</p>

<p><a href="#what-is-the-unix-shell">What is the UNIX shel</a></p>

<p><a href="#why-to-use-the-unix-shell">Why to use the UNIX shell</a></p>

<p><a href="#a-curated-list-of-basic-shell-commands">A curated list of basic shell commands</a></p>

<p>The rest of the content is really useful, but not strictly required to use the shell.</p>

<p><strong>NOTE 1</strong>: Apologies for typos and misspelled words in advance. This document has not been proofread (yet).</p>

<p><strong>NOTE 2</strong>: There is a GitHub repository (<a href="https://github.com/pabloinsente/intro-sc-python">here</a>) associated with this tutorial that you can clone to follow along. You should also be able to recreate the contents of this tutorial in your own machine by simply typing everythin in the shell. If you are not comfortable using Git/Github, you still can read this as a conceptual introduction with examples.</p>

<p><strong>NOTE FOR WINDOWS USERS</strong>: As Windows is not an Unix-like or Linux-based system, most the commands and examples here won’t work, as the Windows Command Prompt and the Windows Power Shell are not bash based. You have a couple of options to follow along:</p>

<ol>
  <li>downloading and installing terminal emulators like <a href="https://gitforwindows.org/">GitBash</a> and <a href="https://www.cygwin.com/">Cygwin</a></li>
  <li>to install the <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows Subsystem for Linux (WSL)</a>.</li>
  <li>open the GitHub repository associated with this tutorial in the cloud environment provided by <strong>MyBinder</strong> by clicking the icon below. Once the environment is ready (it may take a couple of minutes to build), open a terminal there. To open a terminal simply go to “File -&gt; New -&gt; Terminal” or click on the “Terminal” icon under the “Other” section in the landing page. The file with this tutorial is in  <code class="language-plaintext highlighter-rouge">unix-shell/</code> directory named as <strong>unix_shell.md</strong></li>
</ol>

<p><strong>To open MyBinder</strong> -&gt; <a href="https://mybinder.org/v2/gh/pabloinsente/intro-sc-python/master/?urlpath=lab"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a></p>

<p>If you are a beginner, <a href="https://gitforwindows.org/">GitBash</a> and <a href="https://www.cygwin.com/">Cygwin</a> should work just fine, and easier to set-up. The MyBinder environment is a good option too, but you won’t be able to save your work. I do not advise trying (WSL) unless you feel comfortable with using the terminal already. Yet, WSL is the best long-term solution for Windows users.</p>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li><a href="#what-is-the-unix-shell">What is the UNIX shel</a></li>
  <li><a href="#why-to-use-the-unix-shell">Why to use the UNIX shell</a></li>
  <li><a href="#shell-syntax-basics">Shell syntax basics</a></li>
  <li><a href="#standard-input-output-and-error">Standard input, output, and error</a></li>
  <li><a href="#shell-commands-basics">Shell commands basics</a>
    <ul>
      <li><a href="#single-commands">Single commands</a></li>
      <li><a href="#composed-commands">Composed commands</a></li>
    </ul>
  </li>
  <li><a href="#a-curated-list-of-basic-shell-commands">A curated list of basic shell commands</a>
    <ul>
      <li><a href="#basic-commands">Basic commands</a></li>
      <li><a href="#file-commands">File commands</a></li>
      <li><a href="#directory-commands">Directory commands</a></li>
      <li><a href="#system-commands">System commands</a></li>
    </ul>
  </li>
</ul>

<h2 id="what-is-the-unix-shell">What is the UNIX shell</h2>

<p>We begin our journey with the UNIX shell, that cryptic program that runs in your terminal enabling you to do all sort of tasks in your computer. The UNIX shell is a program to <em>interface</em> with the lowest level of UNIX-based operating systems (i.e., the <em>kernel</em>). If you are running any Mac OS or Linux Distribution, you are using a <em>UNIX-based</em> or <em>Unix-like</em> operating system. UNIX-based operating systems have two main parts: the <em>kernel</em> and the <em>utilities</em>.  The <em>kernel</em> is the program managing and allocating the resources of the computer hardware (i.e., the Central Processing Unit or CPU, the Random Access Memory or RAM, and devices like the mouse, speaker, etc). It is a <em>software layer</em> facilitating the control of the computer hardware. The <em>utilities</em> are a set of commands to interface with the kernel. For instance, if you type <code class="language-plaintext highlighter-rouge">pwd</code> in your terminal, the kernel will load a program called <code class="language-plaintext highlighter-rouge">pwd</code> into the RAM, read the program instructions, and display the output, in this case, the current working directory path.</p>

<p>The so-called <em>shell</em>, also happens to be a UNIX utility program. It has a dual identity: as a <em>user interface</em> to the UNIX utilities, and as a <em>programming language</em> facilitating the usage and combination of the UNIX utilities. When you open the terminal, the shell program is loaded into the computer memory. When you type commands in the terminal, the shell reads the commands and converts them into a format that is readable by the kernel to be executed. It provides an interactive instance to start programs, manage files, and processes running in the computer. Since the shell is just a program, many variations have been created since 1969, when <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> developed the the first UNIX implementation at <a href="https://en.wikipedia.org/wiki/Bell_Labs">Bell Labs</a>. The original UNIX shell was written by <a href="https://en.wikipedia.org/wiki/Stephen_R._Bourne">Steve Bourne</a> in 1970, and it’s known as <em>Bourne shell</em> or <em>sh</em>. The Bourne shell was not available for free at the time, which limited its usage by other programmers. To alleviate this problem, in 1988, the Free Software Foundation tasked <a href="https://en.wikipedia.org/wiki/Brian_Fox_(computer_programmer)">Brian Fox</a> to develop an open-source reimplementation of the Bourne shell, the so-called <em>Bourne again shell</em> or <em>bash</em>. Today, the <em>bash</em> shell is probably the most widely use implementation of the Unix shell, and the one that serves as a base for us.</p>

<h2 id="why-to-use-the-unix-shell">Why to use the UNIX shell</h2>

<p>If you haven’t use the shell before, you’re probably accustomed to interact with computer software via <em>Graphical User Interfaces</em> or a <em>GUI</em>. This is perfectly fine for most day to day task, but in a research context, there are many important capabilities that GUI interfaces do not provide. In particular, there are a few key capabilities that I want to highlight:</p>

<ul>
  <li><strong>Repetition</strong>: there are situations when you want to repeat the same action multiple times, sometimes hundreds or thousands of times, actions like changing the extension of a large batch of files or extracting the last line of multiple text files.  Repeating these actions thousands of times with a GUI is beyond unpractical (and probably bad for your health too), and here is where the shell thrives. For example, changing thousands of files with a <em>.txt</em> extension to a <em>.md</em> extension can be accomplished with a single line like this one:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ rename <span class="s2">"s/txt/md/"</span> <span class="k">*</span>.txt
</code></pre></div></div>

<p><strong><em>HEADS UP</em></strong>: In the code blocks, you see will see a  <code class="language-plaintext highlighter-rouge">➜</code> as a  <em>prompt</em> before the actual command. Anything below that indicates the output printed to the terminal. Some commands do not print to the terminal. For instance:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># With standard output to the terminal</span>
➜ <span class="o">[</span>shell-command] <span class="o">[</span>ARGUMENT<span class="o">(</span>s<span class="o">)]</span>
some standard output

<span class="c"># Without standard output to the terminal</span>
➜ <span class="o">[</span>shell-command] <span class="o">[</span>ARGUMENT<span class="o">(</span>s<span class="o">)]</span>
</code></pre></div></div>

<p>If you copy the instructions to your terminal, remember to delete or ignore the ➜ symbol. Your terminal may have <strong>$</strong> symbol or some other character as a prompt, indicating that the terminal is ready to receive input.</p>

<ul>
  <li>
    <p><strong>Automation</strong>: sometimes, instead of repeating the same action, you may want to repeat sequences of actions, or maybe just a single long and complicated action. You may also need to trigger an action automatically in response to some process in your computer. In either case, using the GUI makes you more error prone and slower. Writing the instructions in a <em>shell script</em>, a text file with sequences of shell commands, can facilitate these tasks.</p>
  </li>
  <li>
    <p><strong>Reproducibility</strong>: the fact that you can type sequences of instructions in shell scripts, makes extremely easy to <em>exactly</em> reproduce steps in data processing pipelines. Alternatively, you could take snapshots of your GUI and provide lengthy instructions of what to point and click at every step, but that would take more effort, more time, and increase the probability of error.</p>
  </li>
  <li>
    <p><strong>Remote server connection</strong>: if you ever need to connect to another computer from your computer, this is, a <em>remote server</em>, you will have to use the shell. For instance, <em>High-performance computing</em> (HPC),  <em>High-throughput computing</em> (HTC), and <em>Amazon Web Services</em> (AWS), are all forms of remote computing that require the users to connect and interact via shell commands.</p>
  </li>
</ul>

<h2 id="shell-syntax-basics">Shell syntax basics</h2>

<p>When you pass commands to the terminal, <em>roughly</em> speaking, the shell performs the following set of operations:</p>

<ul>
  <li>
    <p>If you pass starting with the ‘#’ symbol, the shell will ignore that as a ‘<em>comment</em>’ (i.e., it won’t do nothing). Comments are usually used in shell scripts rather than in interactive mode, as descriptors of the action to be taken.</p>
  </li>
  <li>
    <p>If you pass commands without the ‘#’ symbol, the shell reads the inputs and divides them into ‘<em>words</em>’ and ‘<em>operators</em>’. By <em>words</em> we mean any commands like <code class="language-plaintext highlighter-rouge">cd</code> (change directory) or <code class="language-plaintext highlighter-rouge">cat</code> (concatenate files to standard output), plus other constructs related to the specific command; by <em>operators</em> we mean arithmetic operators (like <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">-</code>) , relational operators (like <code class="language-plaintext highlighter-rouge">-eq</code> or <code class="language-plaintext highlighter-rouge">-ne</code>), boolean operators (like <code class="language-plaintext highlighter-rouge">-o</code> or <code class="language-plaintext highlighter-rouge">!</code>), string operators(like <code class="language-plaintext highlighter-rouge">!=</code> or <code class="language-plaintext highlighter-rouge">=</code>), or file operators (like <code class="language-plaintext highlighter-rouge">-b</code> or <code class="language-plaintext highlighter-rouge">c</code>).</p>
  </li>
  <li>
    <p>Then, the shell parse the words and operators into subtypes, performs a series of intermediate steps like expansions and redirections, to finally execute the commands instructions.</p>
  </li>
</ul>

<h2 id="standard-input-output-and-error">Standard input, output, and error</h2>

<p>Before moving into more applied topics, I want to briefly review the concepts of standard input, standard output, and standard error, as I will use them constantly in this tutorial.</p>

<p>Linux or unix-like systems have what is known as “standard streams of data”. Any process run in such systems is initialized with three data streams: <em>standard input</em>, <em>standard ouput</em>, and <em>standard error</em>. By data we mean instructions in plain text formart.</p>

<p><strong>Standard input</strong> or “stdin”, referes the “place” where programs or processes <em>get</em> information from. By default, the shell “takes” input from the keyboard. In other words, standard input is the default place and source of information for Linux/Bash programs.</p>

<p><strong>Standard output</strong> or “stdout”, referes the “place” where programs or processes <em>send</em> information to. By default, the shell output will be directed to the screen or monitor (i.e., printed in the terminal), but it can also for to a text file or a printer. In other words, standard outut is the default place where information is send after processing.</p>

<p><strong>Standard error</strong> or “stderr”, referes the “place” where programs or processes <em>send</em> errors. By default, the shell output will be directed to the screen or the monitor(i.e., printed in the terminal). In other words, standard error is the default place where the shell send messages about processes that went wrong.</p>

<p>Knowing this concepts will make undertanding bash documentation much easier.</p>

<h2 id="shell-commands-basics">Shell commands basics</h2>

<p>Broadly speaking, there two types of shell commands: <em>single</em> commands and <em>composed</em> commands.</p>

<h3 id="single-commands">Single commands</h3>

<p>Single commands are a combination of the command itself, a blank space, a the command arguments. For instance:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> <span class="nt">-a</span>
</code></pre></div></div>

<p>Here we have:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ls</code> : the command to list information about files</li>
  <li>A white space</li>
  <li><code class="language-plaintext highlighter-rouge">-a</code> : an argument saying “do not ignore files starting with .” (hidden files).</li>
</ul>

<h3 id="composed-commands">Composed commands</h3>

<p>Composed commands are created by combining simple commands into <em>pipelines</em>, <em>lists</em>, <em>compounds</em>, and <em>coproceses</em>. We will examine the first three, as are the ones more commonly used.</p>

<h4 id="pipeline">Pipeline</h4>

<table>
  <tbody>
    <tr>
      <td>A pipeline is a sequence of one or more commands separated by one of the control operators ‘</td>
      <td>’ or ‘</td>
      <td>&amp;’, where the <em>output</em> of the first command becomes the <em>input</em> of the next. For instance:</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s2">".txt"</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ls</code> command list the files in the current directory, and the <code class="language-plaintext highlighter-rouge">grep</code> command will print the lines matching the “.txt” extension to the terminal.</p>

<h4 id="lists">Lists</h4>

<table>
  <tbody>
    <tr>
      <td>Lists are a sequence of one or more pipelines separated by one of the operators ‘;’, ‘&amp;’, ‘&amp;&amp;’, or ‘</td>
      <td> </td>
      <td>’. For instance:</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> | <span class="nb">grep</span> <span class="s2">".txt"</span> <span class="o">&amp;&amp;</span> <span class="nb">ls</span> | <span class="nb">grep</span> <span class="s2">".csv"</span>
</code></pre></div></div>

<p>The pipeline on the left side of <em>&amp;&amp;</em> will print the files matching the “.txt” , and the pipeline on the right side, will print the files matching the “.csv” extension, only if the left side was executed successfully.</p>

<h4 id="compound-commands">Compound commands</h4>

<p>Compound commands are shell programming constructs that allow for more complex operations, particularly related to control flow. Compound commands are further divided into: looping constructs, conditional constructs, and grouping constructs. This type of commands begin with a reserved keyword indicating the beginning of the processes, and another keyword to indicate the end. For instance:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="k">while </span>test-commands<span class="p">;</span> <span class="k">do </span>consequent-commands<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>This will tell the shell to repeat certain action (<em>consequent-commands</em>), while some other condition is true (<em>test-commands</em>). The <code class="language-plaintext highlighter-rouge">while</code> keyword indicates the beginning, and the <code class="language-plaintext highlighter-rouge">done</code> keyword indicate the end.</p>

<h2 id="a-curated-list-of-basic-shell-commands">A curated list of basic shell commands</h2>

<p>Now that we have enough background knowledge about the inner workings of the shell, we will review a list of the, in my opinion, most useful commands in a research context. This is the most important and practical part of this tutorial. I don’t pretend to be exhaustive here. More commands will be introduced in later sections.</p>

<p><strong><em>HEADS UP</em></strong>: In case you use the GitHub repository to follow the examples, be aware the exact output showed here may be different, given that this is a project in constant development. However, the instructions and command description hold true.</p>

<h3 id="basic-commands">Basic commands</h3>

<h4 id="echo"><code class="language-plaintext highlighter-rouge">echo</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">echo</code> command display text in the terminal. Is often used in combination with other operators to pass information to a file.</p>

<h5 id="simple-display">Simple display</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">echo </span>this is my first <span class="nb">command
</span>this is my first <span class="nb">command</span>
</code></pre></div></div>

<h5 id="combining-to-pass-text-to-a-file">Combining to pass text to a file</h5>

<p>This line will pass the text into the file, instead of printing in the terminal</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">echo </span>this is my first <span class="nb">command</span> <span class="o">&gt;&gt;</span> first-command.txt
</code></pre></div></div>

<h4 id="clear"><code class="language-plaintext highlighter-rouge">clear</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">clear</code> command clears the terminal. It is often the case the your terminal will get cluttered with information, which can make things confusing to work with, so clearing often it is useful.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ clear
</code></pre></div></div>

<h4 id="man"><code class="language-plaintext highlighter-rouge">man</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">man</code> command allows you to access the on-line reference manual in the terminal. Any time that you want to learn anything about any command, <code class="language-plaintext highlighter-rouge">man</code> will help you.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">man [NAME OF THE COMMAND]</code>.</p>

<p>For instance you can learn about the <code class="language-plaintext highlighter-rouge">man</code> command itself by</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ man man
MAN<span class="o">(</span>1<span class="o">)</span>                        Manual pager utils                        MAN<span class="o">(</span>1<span class="o">)</span>

NAME
       man - an interface to the on-line reference manuals

...
</code></pre></div></div>

<h4 id="help"><code class="language-plaintext highlighter-rouge">help</code></h4>

<p>Technically, <code class="language-plaintext highlighter-rouge">help</code> is not a command, but an option for most commands. I’m including this here because along with <code class="language-plaintext highlighter-rouge">man</code> is one of the most handy tools to learn about and use bash. You can think on <code class="language-plaintext highlighter-rouge">help</code> as quicker way to look at the documentation.</p>

<p>For instance, to learn more about  <code class="language-plaintext highlighter-rouge">man</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ man <span class="nt">--help</span>
Usage: man <span class="o">[</span>OPTION...] <span class="o">[</span>SECTION] PAGE...

  <span class="nt">-C</span>, <span class="nt">--config-file</span><span class="o">=</span>FILE     use this user configuration file
  <span class="nt">-d</span>, <span class="nt">--debug</span>                emit debugging messages
  <span class="nt">-D</span>, <span class="nt">--default</span>              reset all options to their default values
      <span class="nt">--warnings</span><span class="o">[=</span>WARNINGS]  <span class="nb">enable </span>warnings from groff
...
</code></pre></div></div>

<h3 id="file-commands">File commands</h3>

<p>There are some operations that you can perform with files, like text files, comma separated files, and others.</p>

<h4 id="ls"><code class="language-plaintext highlighter-rouge">ls</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">ls</code> command <em>list directory contents</em>.</p>

<p>The syntax is: <code class="language-plaintext highlighter-rouge">ls [OPTION(s)] [FILE(s)]</code></p>

<h5 id="list-directory-contents">List directory contents</h5>

<p>The simples action is to list the contents in the current directory by <code class="language-plaintext highlighter-rouge">ls</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls
</span>a-folder  characters-folder        got-characters.txt           __init__.py
b-folder  got-characters-copy.txt  harry-potter-characters.txt  unix_shell.md
</code></pre></div></div>

<h5 id="list-directory-contents-including-files-starting-with-">List directory contents including files starting with ‘.’</h5>

<p>Hidden files usually begin with a dot in UNIX-bases systems. To list them along with the visible files you need to add the <code class="language-plaintext highlighter-rouge">-a</code> option. Here I’m adding <code class="language-plaintext highlighter-rouge">./characters-folder</code> to list the contents in that directory instead of the current one.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> <span class="nt">-a</span> ./characters-folder
<span class="nb">.</span>   got-characters-copy.txt  harry-potter-characters.txt
..  got-characters.txt       .hidden-file.txt
</code></pre></div></div>

<h5 id="list-directory-contents-in-long-format">List directory contents in long format</h5>

<p>Listing in long format reveals detailed information about each file. To do this we add the <code class="language-plaintext highlighter-rouge">-l</code> option</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> <span class="nt">-l</span>
drwxr-xr-x 3 pablo pablo  4096 Feb  8 15:33 b-folder
drwxr-xr-x 2 pablo pablo  4096 Feb  8 15:40 characters-folder
<span class="nt">-rw-r--r--</span> 1 pablo pablo    18 Feb  8 15:23 got-characters-copy.txt
<span class="nt">-rw-rw-r--</span> 1 pablo pablo    18 Feb  8 12:53 got-characters.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo    19 Feb  8 15:06 harry-potter-characters.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo     0 Feb  8 12:43 __init__.py
<span class="nt">-rw-r--r--</span> 1 pablo pablo 11515 Feb  8 15:46 unix_shell.md
</code></pre></div></div>

<p>There is a lot of information here. Let’s examine this part by part:</p>

<ul>
  <li>The first character indicates the <a href="https://en.wikipedia.org/wiki/Unix_file_types">file type</a>. In this example is <code class="language-plaintext highlighter-rouge">d</code> for directory or <code class="language-plaintext highlighter-rouge">-</code> for regular file. There are more types that you can look up on-line.</li>
  <li>The next nine characters indicate file permissions.
    <ul>
      <li><em>Characters 1-3</em>, are for the <em>user</em>. Here <code class="language-plaintext highlighter-rouge">-rw</code> means <em>reading</em> and <em>writing</em> permissions</li>
      <li><em>Characters 4-6</em> are for the <em>group</em>. Here <code class="language-plaintext highlighter-rouge">-r-</code> means <em>reading</em> permission only</li>
      <li>Characters 7-9 are for <em>others</em>. Here <code class="language-plaintext highlighter-rouge">-r-</code> means <em>reading</em> permission only</li>
    </ul>
  </li>
  <li>The number after the permission string indicates the the number of <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a> to the file</li>
  <li>Next, the <code class="language-plaintext highlighter-rouge">pablo pablo</code> indicates the <em>file owner</em> and the <em>group</em>, respectively.</li>
  <li>The number after the group name, indicates the file size in bytes.</li>
  <li>Next, the <code class="language-plaintext highlighter-rouge">Feb  8 15:33</code> indicates the <em>date</em> and <em>time</em> of the <em>last modification</em> to the file.</li>
  <li>Finally, the last column display the file name.</li>
</ul>

<h5 id="list-directory-contents-by-custom-order">List directory contents by custom order</h5>

<p>The <code class="language-plaintext highlighter-rouge">ls</code> command will sort files alphabetically by default.  You can use the <code class="language-plaintext highlighter-rouge">--sort=KEYWORD</code> to sort files by <em>size</em>, <em>time</em>, <em>version</em>, <em>extension</em>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># sort by size</span>
➜ <span class="nb">ls</span> <span class="nt">-l</span> <span class="nt">--sort</span><span class="o">=</span>size
total 40
<span class="nt">-rw-r--r--</span> 1 pablo pablo 13396 Feb  8 16:09 unix_shell.md
drwxr-xr-x 2 pablo pablo  4096 Feb  8 15:25 a-folder
drwxr-xr-x 3 pablo pablo  4096 Feb  8 15:33 b-folder
drwxr-xr-x 2 pablo pablo  4096 Feb  8 15:40 characters-folder
<span class="nt">-rw-r--r--</span> 1 pablo pablo    19 Feb  8 15:06 harry-potter-characters.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo    18 Feb  8 15:23 got-characters-copy.txt
<span class="nt">-rw-rw-r--</span> 1 pablo pablo    18 Feb  8 12:53 got-characters.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo     0 Feb  8 12:43 __init__.py
<span class="c"># sor by time</span>
➜ <span class="nb">ls</span> <span class="nt">-l</span> <span class="nt">--sort</span><span class="o">=</span><span class="nb">time
</span>total 40
<span class="nt">-rw-r--r--</span> 1 pablo pablo 13396 Feb  8 16:09 unix_shell.md
drwxr-xr-x 2 pablo pablo  4096 Feb  8 15:40 characters-folder
drwxr-xr-x 3 pablo pablo  4096 Feb  8 15:33 b-folder
drwxr-xr-x 2 pablo pablo  4096 Feb  8 15:25 a-folder
<span class="nt">-rw-r--r--</span> 1 pablo pablo    18 Feb  8 15:23 got-characters-copy.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo    19 Feb  8 15:06 harry-potter-characters.txt
<span class="nt">-rw-rw-r--</span> 1 pablo pablo    18 Feb  8 12:53 got-characters.txt
<span class="nt">-rw-r--r--</span> 1 pablo pablo     0 Feb  8 12:43 __init__.py
</code></pre></div></div>

<h4 id="cat"><code class="language-plaintext highlighter-rouge">cat</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">cat</code> command <em>concatenates and print contents of a file to standard output</em> (I know, confusingly, it has nothing to do with cats).</p>

<p>The syntax is: <code class="language-plaintext highlighter-rouge">cat [OPTION(s)] [FILE(s)]</code></p>

<h5 id="display-files-contents">Display file’s contents</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">cat </span>harry-potter-characters.txt
Harry
Hermione
Ron
</code></pre></div></div>

<h5 id="display-multiple-files-contents">Display multiple file’s contents</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">cat </span>got-characters.txt
Harry
Hermione
Ron
Jon
Arya
Daenerys
</code></pre></div></div>

<h5 id="display-numerated-files-contents">Display numerated file’s contents</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">cat</span> <span class="nt">-n</span> got-characters.txt
1	Jon
2	Arya
3	Daenerys
</code></pre></div></div>

<h5 id="create-a-new-file-concatenating-standard-input-text">Create a new file concatenating standard input text</h5>

<p>This will prompt you to enter input text. You type some text and press <code class="language-plaintext highlighter-rouge">enter</code>. Once you are done, press <code class="language-plaintext highlighter-rouge">Control + D</code> to exit.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">cat</span> <span class="o">&gt;</span>new-characters.txt
Dumbledore
Voldemort
Jaime
Tyrion
</code></pre></div></div>

<p>Now, if you type <code class="language-plaintext highlighter-rouge">cat new-characters.txt</code> the list of names will be printed in the terminal.</p>

<h4 id="cp"><code class="language-plaintext highlighter-rouge">cp</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">cp</code> command <em>copy files and directories</em>.</p>

<p>The syntax is: <code class="language-plaintext highlighter-rouge">cp [OPTION(s)][SOURCE] [DESTINY]</code></p>

<h5 id="copy-contents-of-a-file-into-another">Copy contents of a file into another</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>got-characters.txt got-characters-copy.txt
</code></pre></div></div>

<p>If you <code class="language-plaintext highlighter-rouge">cat</code> the contents of <code class="language-plaintext highlighter-rouge">got-characters-copy.txt</code> you will see the duplicated contents</p>

<h5 id="copy-a-file-from-one-directory-into-another">Copy a file from one directory into another</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>got-characters.txt ./a-folder
</code></pre></div></div>

<h5 id="copy-a-directory-into-another">Copy a directory into another</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> <span class="nt">-r</span> /a-foler ./b-folder
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-r</code> option stand for <em>recursive</em>. This option is required to copy directories.</p>

<h4 id="touch"><code class="language-plaintext highlighter-rouge">touch</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">touch</code> command changes files timestamps. However, <code class="language-plaintext highlighter-rouge">touch</code> is commonly used to create new empty files.</p>

<p>To change timestamps of an <em>existing</em> <em>file</em> the syntax is <code class="language-plaintext highlighter-rouge">touch [OPTION(s)] [FILE(s)]</code></p>

<p>To create an <em>new empty file</em> the syntax is <code class="language-plaintext highlighter-rouge">touch [FILE(s)]</code></p>

<h5 id="change-the-time-stamp-of-an-existing-file">Change the time-stamp of an existing file</h5>

<p>First, I’ll review the access and modification times using the <code class="language-plaintext highlighter-rouge">stat</code> command, to then use the <code class="language-plaintext highlighter-rouge">touch</code> command to change those times, and finally <code class="language-plaintext highlighter-rouge">stat</code> again to verify the changes.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># review access time and modification time</span>
➜ <span class="nb">stat </span>harry-potter-characters.txt 
  File: harry-potter-characters.txt
  Size: 19        	Blocks: 8          IO Block: 4096   regular file
Device: 10307h/66311d	Inode: 3440036     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/   pablo<span class="o">)</span>   Gid: <span class="o">(</span> 1000/   pablo<span class="o">)</span>
Access: 2020-02-08 15:39:41.039475209 <span class="nt">-0600</span>
Modify: 2020-02-08 15:06:40.426141133 <span class="nt">-0600</span>
Change: 2020-02-08 15:06:40.426141133 <span class="nt">-0600</span>
 Birth: -

<span class="c"># change access and modficiation time</span>
<span class="nb">touch</span> <span class="nt">-am</span> harry-potter-characters.txt 

<span class="c"># review access time and modification time after change</span>
➜ <span class="nb">stat </span>harry-potter-characters.txt     
  File: harry-potter-characters.txt
  Size: 19        	Blocks: 8          IO Block: 4096   regular file
Device: 10307h/66311d	Inode: 3440036     Links: 1
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span> 1000/   pablo<span class="o">)</span>   Gid: <span class="o">(</span> 1000/   pablo<span class="o">)</span>
Access: 2020-02-08 17:37:05.054635614 <span class="nt">-0600</span>
Modify: 2020-02-08 17:37:05.054635614 <span class="nt">-0600</span>
Change: 2020-02-08 17:37:05.054635614 <span class="nt">-0600</span>
 Birth: -
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">-a</code> and <code class="language-plaintext highlighter-rouge">-m</code> options change the <em>access time</em> and <em>modification time</em>, respectively. If you compare the <code class="language-plaintext highlighter-rouge">Access</code> and <code class="language-plaintext highlighter-rouge">Modify</code> entries from the top and the bottom of the code block, you’ll see the changes.</p>

<h5 id="create-a-new-empty-file">Create a new empty file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">touch </span>my-empty-file.txt
</code></pre></div></div>

<p>This is the most common use of the touch command. You can create multiple empty files by:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">touch </span>my-empty-file-1.txt my-empty-file-2.txt my-empty-file-3.txt
</code></pre></div></div>

<h4 id="mv"><code class="language-plaintext highlighter-rouge">mv</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">mv</code> command moves files around your file system, and it is also used to rename files.</p>

<p>The syntax to move files is: <code class="language-plaintext highlighter-rouge">mv [OPTION(s)]]  [SOURCE] [DESTINY]</code></p>

<p>The syntax to rename a file is: <code class="language-plaintext highlighter-rouge">mv [OPTION(s)] [CURRENT NAME] [WANTED NAME]</code></p>

<h5 id="moving-a-file">Moving a file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">mv </span>my-empty-file.txt ./a-folder
</code></pre></div></div>

<p>Notice that here you can use either absolute or relative paths.</p>

<h5 id="renaming-a-file">Renaming a file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">mv </span>my-empty-file-3.txt my-empty-file-4.txt
</code></pre></div></div>

<h4 id="grep"><code class="language-plaintext highlighter-rouge">grep</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">grep</code> command print lines matching a desired pattern given some standard input. By standard input, we mean content printed to the terminal or a file. This is one of the most handy command line tools in bash, particularly when combined with other tools like <code class="language-plaintext highlighter-rouge">ls</code> , <code class="language-plaintext highlighter-rouge">find</code>, and <a href="'https://en.wikipedia.org/wiki/Regular_expression'">regular expressions</a>. The <code class="language-plaintext highlighter-rouge">grep</code> documentation is very extensive, and it can be treated as a topic in itself one combined with regular expression. Here we will review a few of the main <code class="language-plaintext highlighter-rouge">grep</code> functions.</p>

<p>The syntax for basic pattern matching is <code class="language-plaintext highlighter-rouge">grep [OPTION(s)] [PATTERN] [FILE(s)]</code></p>

<p>The syntax for pattern matching as extended regular expressions is <code class="language-plaintext highlighter-rouge">grep [OPTION(s)] -e [PATTERN] [FILE(s)]</code></p>

<p>The syntax for pattern matching using the <code class="language-plaintext highlighter-rouge">[PATTERN]</code> as a list of fixed string (instead of regular expression) is  <code class="language-plaintext highlighter-rouge">grep [OPTION(s)] -f [STRING] [FILE(s)]</code></p>

<h5 id="basic-pattern-matching">Basic pattern matching</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">grep </span>Harry harry-potter-characters.txt 
Harry
➜ <span class="nb">grep </span>Jon got-characters.txt 
Jon
</code></pre></div></div>

<h5 id="extended-regular-expression-pattern-matching">Extended regular expression pattern matching</h5>

<p>In Linux, there is no difference between basic and extended pattern matching. In other system, it may be the case that basic pattern matching is not as general and powerful as extended pattern matching. If you are in need of using complex regular expression patterns to search, you may need to add the <code class="language-plaintext highlighter-rouge">e</code> option for that to work. I’ll not cover this option now since regular expressions knowledge is required.</p>

<h5 id="string-pattern-matching">String pattern matching</h5>

<p>The difference between basic pattern matching and string pattern matching, is that the latter does not use regular expression rules to search. For instance, suppose you want to search something like <code class="language-plaintext highlighter-rouge">.*</code> in a file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># pattern matching with regular expressions</span>
➜ <span class="nb">grep</span> <span class="s2">"</span><span class="se">\.\*</span><span class="s2">"</span> filename
<span class="c"># pattern matching with strings</span>
➜ <span class="nb">grep</span> <span class="nt">-F</span> <span class="s2">".*"</span> filename
</code></pre></div></div>

<p>In the pattern matching case you have to add the backslash <a href="https://en.wikipedia.org/wiki/Escape_character">escape character</a> to prevent the interpretation of the <code class="language-plaintext highlighter-rouge">*</code> as a <a href="https://en.wikipedia.org/wiki/Wildcard_character">wildcard character</a>. In the string search case, the <code class="language-plaintext highlighter-rouge">.*</code> is interpreted literally, so no escape character is needed.</p>

<h5 id="using-the-output-of-another-command-as-grep-input">Using the output of another command as <code class="language-plaintext highlighter-rouge">grep</code> input</h5>

<p>The <code class="language-plaintext highlighter-rouge">grep</code> command is often used in combination with others bash tools. For instance, we can list all the files in the current directory with <code class="language-plaintext highlighter-rouge">ls</code>, then pass the output as input to <code class="language-plaintext highlighter-rouge">grep</code>, and search for all files containing the string “got”.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">ls</span> | <span class="nb">grep </span>got                    
got-characters-copy.txt
got-characters.txt
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">wc</code></p>

<p>The <code class="language-plaintext highlighter-rouge">wc</code> command prints how many new lines, words, and bytes are in  file.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">wc [OPTION(s)] [FILE]</code></p>

<h5 id="basic-count">Basic count</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">wc </span>got-characters.txt
3  3 18 got-characters.txt
</code></pre></div></div>

<p>In order, this is 3 words, 3 new lines, and 18 bytes.</p>

<h5 id="count-words-only">Count words only</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">wc</span> <span class="nt">-w</span> got-characters.txt
3 got-characters.txt
</code></pre></div></div>

<h5 id="count-new-lines-only">Count new lines only</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">wc</span> <span class="nt">-w</span> got-characters.txt
3 got-characters.txt
</code></pre></div></div>

<h5 id="count-the-number-of-characters">Count the number of characters</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">wc</span> <span class="nt">-m</span> got-characters.txt
18 got-characters.txt
</code></pre></div></div>

<h5 id="count-the-number-of-bytes">Count the number of bytes</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">wc</span> <span class="nt">-c</span> got-characters.txt
18 got-characters.txt
</code></pre></div></div>

<h4 id="head"><code class="language-plaintext highlighter-rouge">head</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">head</code> command prints the first elements of a file, by default, the first 10 elements.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">head [OPTION] [FILE]</code></p>

<h5 id="printing-the-first-10-lines-of-a-file">Printing the first 10 lines of a file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">head </span>fruits.txt
apple
pear
peach
grape
kiwi
melon
fig
cucumber
cherry
banana
</code></pre></div></div>

<h5 id="printing-the-first-n-number-of-lines-of-a-file">Printing the first n number of lines of a file</h5>

<p>You can print an arbitrary number <code class="language-plaintext highlighter-rouge">n</code> of lines in a file by using th <code class="language-plaintext highlighter-rouge">n</code> option.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">head</span> <span class="nt">-n</span> 5 fruits.txt
apple
pear
peach
grape
kiwi
</code></pre></div></div>

<h5 id="printing-the-first-n-number-of-bytes-of-a-file">Printing the first n number of bytes of a file</h5>

<p>You can print an arbitrary number <code class="language-plaintext highlighter-rouge">n</code> of bytes in a file by using th <code class="language-plaintext highlighter-rouge">-c</code> option.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">head</span> <span class="nt">-c</span> 20 fruits.txt
apple
pear
peach
</code></pre></div></div>

<h5 id="tail"><code class="language-plaintext highlighter-rouge">tail</code></h5>

<p>The <code class="language-plaintext highlighter-rouge">tail</code> command prints the last elements of a file, by default, the last 10 elements.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">tail [OPTION] [FILE]</code></p>

<h5 id="printing-the-last-10-lines-of-a-file">Printing the last 10 lines of a file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">tail </span>fruits.txt
cucumber
cherry
banana
avocado
coconut
orange
papaya
watermelon
mango
</code></pre></div></div>

<h5 id="printing-the-last-n-lines-of-a-file">Printing the last n lines of a file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">tail</span> <span class="nt">-n</span> 5 fruits.txt
coconut
orange
papaya
watermelon
mango
</code></pre></div></div>

<h5 id="printing-the-last-n-number-of-bytes-of-a-file">Printing the last n number of bytes of a file</h5>

<p>You can print an arbitrary number <code class="language-plaintext highlighter-rouge">n</code> of bytes in a file by using th <code class="language-plaintext highlighter-rouge">-c</code> option.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">tail</span> <span class="nt">-c</span> 20 fruits.txt
ya
watermelon
mango
</code></pre></div></div>

<h4 id="rm"><code class="language-plaintext highlighter-rouge">rm</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">rm</code> command removes files or directories. This another very important and useful shell tool.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">rm [OPTION(s)] [FILE]</code></p>

<h5 id="removing-a-single-file">Removing a single file</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">rm </span>my-empty-file-4.txt
</code></pre></div></div>

<p>You won’t see any printed output but you can check the file has been removed with <code class="language-plaintext highlighter-rouge">ls</code>.</p>

<h5 id="removing-multiple-files">Removing multiple files</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">rm </span>my-empty-file-1.txt my-empty-file-2.txt
</code></pre></div></div>

<h5 id="removing-a-directory">Removing a directory</h5>

<p><code class="language-plaintext highlighter-rouge">rm</code> alone won’t work this time. The <code class="language-plaintext highlighter-rouge">-r</code> flag (“recursively”) must be added.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># create an empty folder as example</span>
➜ <span class="nb">mkdir </span>empty-dir
➜ <span class="nb">rm</span> <span class="nt">-r</span> empt-dir
</code></pre></div></div>

<h3 id="directory-commands">Directory commands</h3>

<p>Directory commands are actions you can perform with folders or directories.</p>

<h4 id="pwd">pwd</h4>

<p>The <code class="language-plaintext highlighter-rouge">pwd</code> prints the current workind directory to the terminal.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">pwd [OPTION(s)]</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># you will see your own full path printed out to the terminal</span>
➜ <span class="nb">pwd</span>
/mnt/c/Users/pablo/Desktop/projects/unix_shell
</code></pre></div></div>

<h4 id="cd">cd</h4>

<p>The <code class="language-plaintext highlighter-rouge">cd</code> command changes the current working directory to another.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">cd [OPTION(s)] [DIRECTORY]</code></p>

<h5 id="move-to-an-specific-folder-down">Move to an specific folder “down”</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># move from current directory to characrers-folder/</span>
➜ <span class="nb">cd </span>characters-folder/
</code></pre></div></div>

<h5 id="move-one-folder-up">Move one folder up</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># move back from characrers-folder/ to unix_shell/</span>
➜ <span class="nb">cd</span> ..
</code></pre></div></div>

<h5 id="move-two-folders-up">Move two folders up</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># go back to unix_shell/ first</span>
➜ <span class="nb">cd </span>unix_shell/
<span class="c"># move back from unix_shell/ to repo-directory</span>
➜ <span class="nb">cd</span> ../..
</code></pre></div></div>

<p>You can follow the patten of <code class="language-plaintext highlighter-rouge">../</code> to move several directories up.</p>

<h5 id="move-the-home-directory">Move the home directory</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># this is no mistake, cd alone would change the directory to home</span>
➜ <span class="nb">cd</span>
</code></pre></div></div>

<h4 id="mkdir">mkdir</h4>

<p>The <code class="language-plaintext highlighter-rouge">mkdir</code> command creates a new directory.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">mkdir [OPTION(s)] [DIRECTORY-NAME]</code></p>

<h5 id="make-a-single-directory">Make a single directory</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">mkdir </span>my-folder
</code></pre></div></div>

<h5 id="make-multiple-directories">Make multiple directories</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">mkdir </span>my-folder-2 my-folder-3
</code></pre></div></div>

<p>You can create as many directories as you need “below” the current working directory by following the same patter</p>

<h3 id="system-commands">System commands</h3>

<h4 id="ps">ps</h4>

<p>The <code class="language-plaintext highlighter-rouge">ps</code> command prints a snapshot of the corrent active processes to the terminal. This command has many options which are useful for system administrators and othes. For our purposes, just knowing <code class="language-plaintext highlighter-rouge">ps</code> does that is enough.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">ps [OPTION(s)]</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># your output will differ depending on your active processes</span>
➜ ps
PID   TTY          TIME CMD
  8   pts/0    00:00:01 zsh
 1042 pts/0    00:00:00 ps
</code></pre></div></div>

<h4 id="kill">kill</h4>

<p>The <code class="language-plaintext highlighter-rouge">kill</code> command terminates an active process.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">kill PID</code> or <code class="language-plaintext highlighter-rouge">kill -s signalName PID</code></p>

<p>The PID is the process identification number. You can find the PID of a process with the <code class="language-plaintext highlighter-rouge">ps</code> command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill </span>PID
</code></pre></div></div>

<p>Here is an example of when I have used <code class="language-plaintext highlighter-rouge">kill</code>: I closed a Jupyter Notebook session by typying <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Z</code> in the terminal, instead of <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">C</code>. Sometimes happens that if you try launch Jupyter again won’t work because the default port is in use. Then you have to terminate the process Jupyter process, which is still running in the background, to be able to launch Jupyter again.</p>

<h4 id="top">top</h4>

<h4 id="whoami">whoami</h4>

<p>The <code class="language-plaintext highlighter-rouge">whoami</code> command prints the current user id to the terminal.</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">whoami [OPTION's]</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># here you will see your used id</span>
➜ <span class="nb">whoami
</span>pablo
</code></pre></div></div>

<h3 id="inputoutput-redirection-commands">Input/Output redirection commands</h3>

<p>As I explained before, the unix shell has three streams of data: input, output, and error messages. Such information can be redirected before execution. An example is the pipeline <code class="language-plaintext highlighter-rouge">|</code> that we reviewd in the composed commands section.</p>

<h4 id="redirection-operators">Redirection operators</h4>

<p>Redirection operators are special characters used for change the direction in which streams of data flow. They can be located before or in between commands. Here is a list of several common operators.</p>

<h5 id="redirecting-input">Redirecting input</h5>

<p>To redirect input we use the <code class="language-plaintext highlighter-rouge">&lt;</code> operator as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">cat</span> &lt; got-characters.txt
Jon
Arya
Daenerys
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">cat</code> command is “fed” with the text file as input.</p>

<h5 id="redirecting-output">Redirecting output</h5>

<p>To redirect output we use the <code class="language-plaintext highlighter-rouge">&gt;</code> operator as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">echo</span> <span class="s2">"catbug"</span> <span class="o">&gt;</span> catbug.txt
</code></pre></div></div>

<p>This will cause the outut of <code class="language-plaintext highlighter-rouge">echo "catbug"</code> to be directed towards the catbug.txt. You can check that printing the catbug.txt contents.</p>

<h5 id="appending-redirected-output">Appending redirected output</h5>

<p>To append output we use the <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> operator as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ <span class="nb">echo</span> <span class="s2">"Plum"</span> <span class="o">&gt;&gt;</span> catbug.txt
</code></pre></div></div>

<p>This will cause to append (i.e., print at the end) the output of <code class="language-plaintext highlighter-rouge">echo "Plum"</code> , to the  catbug.txt file. If you use <code class="language-plaintext highlighter-rouge">&gt;</code> instead, the contents will be replaced rather than appended. This is you will get only:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plum
</code></pre></div></div>

<p>Instead of:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catbug
Plum
</code></pre></div></div>

<h5 id="redirecting-standard-output-and-error">Redirecting standard output and error</h5>

<p>There are instances where in addition to the output of a process, you may want to print any error messages generated for something that went wrong. An example of this is running long processes, which may take hours, which you leave unattended. if something goes wrong while you are away, having the error messages printed to a text file may be very useful to fix your code later.</p>

<p>This action is done with the <code class="language-plaintext highlighter-rouge">&amp;&gt;</code> operator as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>nonexistent-file.txt &amp;&gt; empty.txt
</code></pre></div></div>

<p>The empty.txt file now must contain the “cat: nonexistent-file.txt: No such file or directory” message. If you use <code class="language-plaintext highlighter-rouge">&gt;</code> instead, the error message will be printed to the terminal, and the empty.txt file will be empty.</p>

<p><a href="#table-of-contents">back to the top</a></p>

<h2 id="future-sections">Future sections</h2>

<p>This tutorial is not complete. I was not planning to release this yet, but it became necessary to help out some students to learn shell basics. These are the topics I hope to cover later.</p>

<ul>
  <li>Shell functions basics</li>
  <li>Shell variables basics</li>
  <li>Shell flow control basics</li>
  <li>Shell pattern matching basics</li>
  <li>Shell scripting basics</li>
  <li>Alternative shells</li>
  <li>Additional resources to learn</li>
</ul>

<p><a href="#table-of-contents">back to the top</a></p>

</article>

      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>mozillo</b>
    </span>
    
    <span>© 2025</span>
  </a>
</footer>

  
</body>

</html>